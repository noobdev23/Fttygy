<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI-like Eye Scanner — Downloadable index.html</title>
<style>
  :root{--bg:#0f1724;--card:#071733;--accent:#3ddc97;--muted:#9fb4c8}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#eaf6ff;background:linear-gradient(180deg,#071026,#081628);-webkit-font-smoothing:antialiased}
  .wrap{max-width:980px;margin:18px auto;padding:18px;border-radius:12px}
  header{display:flex;align-items:center;gap:12px}
  header h1{margin:0;font-size:18px}
  .grid{display:grid;grid-template-columns:1fr 340px;gap:16px;margin-top:14px}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:14px;border-radius:10px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  video{width:100%;border-radius:8px;background:#000;display:block}
  .overlay{position:relative}
  .box{position:absolute;border:2px dashed rgba(255,255,255,0.25);left:50%;top:50%;width:240px;height:120px;transform:translate(-50%,-50%);border-radius:8px;pointer-events:none}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  button{background:var(--accent);border:0;padding:10px 12px;border-radius:8px;color:#05233a;cursor:pointer;font-weight:700}
  .muted{color:var(--muted);font-size:13px}
  .result{font-weight:700;margin-top:8px}
  footer{margin-top:12px;color:var(--muted);font-size:13px}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <svg width="44" height="44" viewBox="0 0 24 24" fill="none" style="border-radius:8px;background:linear-gradient(180deg,#06314b,#05365a);padding:6px"><path d="M12 4C7 4 2.73 7.11 1 11.5 2.73 15.89 7 19 12 19s9.27-3.11 11-7.5C21.27 7.11 17 4 12 4z" fill="#3ddc97"/></svg>
      <div>
        <h1>AI-like Eye Scanner — Quick Check</h1>
        <div class="muted">Uses your webcam + simple heuristics to measure blink rate, attention and give a friendly "vision score". Not a medical device.</div>
      </div>
    </header>

    <div class="grid">
      <main class="card">
        <section>
          <h3 style="margin:0 0 8px 0">Camera & Scanner</h3>
          <div class="overlay">
            <video id="video" autoplay playsinline></video>
            <div class="box" aria-hidden="true"></div>
          </div>

          <div class="controls">
            <button id="startBtn">Start Camera</button>
            <button id="scanBtn" disabled>Start Scan</button>
            <button id="stopBtn" disabled>Stop Scan</button>
        
          </div>

          <div id="status" class="muted" style="margin-top:10px">Camera is off.</div>

          <div id="metrics" style="margin-top:12px;display:none">
            <div class="muted">Scan time: <span id="scanTime">0</span>s</div>
            <div class="muted">Blinks detected: <span id="blinks">0</span></div>
            <div class="muted">Fixation score: <span id="fixScore">—</span></div>
            <div class="result">Vision score: <span id="visionScore">—</span></div>
          </div>

          <div style="margin-top:12px" class="muted">Instructions: Allow camera access, position your face inside the dashed box, keep still until scan completes. Results are heuristic and for fun / screening only.</div>
        </section>
      </main>

      <aside class="card">
        <h3 style="margin:0 0 8px 0">About this "AI"</h3>
        <p class="muted">This page uses a lightweight, purely client-side method: it samples small regions inside the overlay box from the camera feed and looks for brightness changes consistent with blinking and head movement. It does <strong>not</strong> diagnose eye disease.</p>

        <h4 style="margin-top:12px">Tips</h4>
        <ol class="muted" style="padding-left:18px">
          <li>Sit in a well-lit room (no strong backlight).</li>
          <li>Place the camera at eye level and align your eyes inside the dashed box.</li>
          <li>Hold still during the 15–30s scan for best results.</li>
        </ol>

        <div style="margin-top:12px">
          <button id="resetBtn">Reset Results</button>
        </div>
      </aside>
    </div>

    <footer>
      ⚠ This is a screening tool. For real eye problems, see an optometrist or ophthalmologist.
    </footer>
  </div>

<script>
(async function(){
  const video = document.getElementById('video');
  const startBtn = document.getElementById('startBtn');
  const scanBtn = document.getElementById('scanBtn');
  const stopBtn = document.getElementById('stopBtn');
  const status = document.getElementById('status');
  const metrics = document.getElementById('metrics');
  const scanTimeEl = document.getElementById('scanTime');
  const blinksEl = document.getElementById('blinks');
  const fixScoreEl = document.getElementById('fixScore');
  const visionScoreEl = document.getElementById('visionScore');
  const downloadBtn = document.getElementById('downloadBtn');
  const resetBtn = document.getElementById('resetBtn');

  let stream = null;
  let scanning = false;
  let rafId = null;
  let canvas = document.createElement('canvas');
  let ctx = canvas.getContext('2d');
  let blinkCount = 0;
  let samples = [];
  let startTime = 0;

  function updateStatus(t){
    status.textContent = t;
  }

  startBtn.addEventListener('click', async ()=>{
    try{
      stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'}, audio:false});
      video.srcObject = stream;
      updateStatus('Camera on — align your eyes inside the dashed box.');
      scanBtn.disabled = false;
    }catch(err){
      updateStatus('Camera access denied or unavailable: ' + (err.message||err));
      console.error(err);
    }
  });

  stopBtn.addEventListener('click', ()=>{
    stopScan();
  });

  resetBtn.addEventListener('click', ()=>{
    blinkCount = 0;
    samples = [];
    startTime = 0;
    scanTimeEl.textContent = '0';
    blinksEl.textContent = '0';
    fixScoreEl.textContent = '—';
    visionScoreEl.textContent = '—';
    metrics.style.display = 'none';
    updateStatus('Reset. Start a new scan when ready.');
  });

  downloadBtn.addEventListener('click', ()=>{
    // Trigger download of this page itself
    const blob = new Blob([document.documentElement.outerHTML], {type: 'text/html'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'index.html';
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  scanBtn.addEventListener('click', ()=>{
    if(!stream){ updateStatus('Start the camera first.'); return; }
    if(scanning) return;
    startScan();
  });

  function getOverlayRect(){
    // compute where the dashed box sits relative to the video element
    const vidRect = video.getBoundingClientRect();
    const boxW = Math.min(vidRect.width * 0.6, 300);
    const boxH = boxW * 0.5;
    const left = vidRect.left + vidRect.width/2 - boxW/2;
    const top = vidRect.top + vidRect.height/2 - boxH/2;
    // translate to video pixel coords
    const vw = video.videoWidth || 640;
    const vh = video.videoHeight || 480;
    const scaleX = vw / vidRect.width;
    const scaleY = vh / vidRect.height;
    return {
      x: Math.round((left - vidRect.left) * scaleX),
      y: Math.round((top - vidRect.top) * scaleY),
      w: Math.round(boxW * scaleX),
      h: Math.round(boxH * scaleY)
    };
  }

  function sampleFrame(){
    if(!video.videoWidth) return null;
    // ensure canvas matches video resolution for accurate sampling
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const r = getOverlayRect();
    // if box out-of-range fallback to center area
    const sx = Math.max(0, r.x);
    const sy = Math.max(0, r.y);
    const sw = Math.min(r.w || Math.round(canvas.width*0.5), canvas.width - sx);
    const sh = Math.min(r.h || Math.round(canvas.height*0.4), canvas.height - sy);
    if(sw <= 0 || sh <= 0) return null;
    const imgd = ctx.getImageData(sx, sy, sw, sh);
    // compute mean brightness per column to try approximate eye regions
    const data = imgd.data;
    let cols = Math.min(6, sw);
    let colSums = new Array(cols).fill(0);
    let colCounts = new Array(cols).fill(0);
    for(let y=0;y<sh;y++){
      for(let x=0;x<sw;x++){
        const idx = (y*sw + x)*4;
        const r = data[idx], g = data[idx+1], b = data[idx+2];
        const brightness = 0.299*r + 0.587*g + 0.114*b;
        const col = Math.floor(x / sw * cols);
        colSums[col] += brightness;
        colCounts[col] += 1;
      }
    }
    const colMeans = colSums.map((s,i)=> s / (colCounts[i] || 1));
    const meanAll = colMeans.reduce((a,b)=>a+b,0)/colMeans.length;
    return {colMeans, meanAll, timestamp: performance.now()};
  }

  function startScan(){
    scanning = true;
    scanBtn.disabled = true;
    stopBtn.disabled = false;
    metrics.style.display = '';
    blinkCount = 0;
    samples = [];
    startTime = Date.now();
    updateStatus('Scanning... stay still for 15 seconds.');
    let lastMean = null;
    let blinkCooldown = 0;
    let checks = 0;
    function step(){
      const s = sampleFrame();
      if(s){
        samples.push(s);
        // detect blink: a quick drop in mean brightness relative to running average
        if(lastMean !== null){
          const diff = lastMean - s.meanAll;
          // if big drop relative to last mean -> blink
          if(diff > 25 && blinkCooldown <= 0){
            blinkCount++;
            blinksEl.textContent = blinkCount;
            blinkCooldown = 6; // skip next few frames to avoid double-count
          }
          blinkCooldown = Math.max(0, blinkCooldown-1);
        }
        // running smoothing for lastMean
        lastMean = lastMean === null ? s.meanAll : (lastMean*0.85 + s.meanAll*0.15);
      }
      const elapsed = Math.round((Date.now() - startTime)/1000);
      scanTimeEl.textContent = elapsed;
      // stop after 15 seconds
      if(elapsed >= 15){
        finishScan();
        return;
      }
      rafId = requestAnimationFrame(step);
    }
    rafId = requestAnimationFrame(step);
  }

  function stopScan(){
    scanning = false;
    if(rafId) cancelAnimationFrame(rafId);
    scanBtn.disabled = false;
    stopBtn.disabled = true;
    updateStatus('Scan stopped.');
  }

  function finishScan(){
    scanning = false;
    if(rafId) cancelAnimationFrame(rafId);
    scanBtn.disabled = false;
    stopBtn.disabled = true;
    const elapsed = Math.round((Date.now() - startTime)/1000);
    // compute fixation score: how stable the meanAll was (low variance -> good fixation)
    const means = samples.map(s=>s.meanAll);
    const avg = means.reduce((a,b)=>a+b,0)/Math.max(1,means.length);
    const variance = means.reduce((a,b)=>a + (b-avg)*(b-avg),0)/Math.max(1,means.length);
    // map variance to fixation score (lower variance -> higher score)
    const fixScore = Math.max(0, Math.round(Math.max(0, 100 - variance)));
    // compute a simple vision score combining blink rate and fixation:
    // ideal blink rate during 15s is ~1-4 blinks (4-12 per minute). Penalize too many or zero blinks.
    const blinks = blinkCount;
    let blinkPenalty = 0;
    if(blinks < 1) blinkPenalty = 20;
    else if(blinks <= 3) blinkPenalty = 0;
    else if(blinks <= 6) blinkPenalty = 10;
    else blinkPenalty = 25;
    const visionScore = Math.max(10, Math.round((fixScore*0.75) - blinkPenalty));
    scanTimeEl.textContent = elapsed;
    blinksEl.textContent = blinks;
    fixScoreEl.textContent = fixScore;
    visionScoreEl.textContent = visionScore + ' / 100';
    updateStatus('Scan completed — friendly, heuristic result.');
  }

  // cleanup on page unload
  window.addEventListener('beforeunload', ()=>{
    if(stream){
      stream.getTracks().forEach(t=>t.stop());
    }
  });

})();
</script>

</section>

</body>
</html>
